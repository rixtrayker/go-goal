package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"database/sql"
	"fmt"
	"strconv"
	"time"
	"strings"

	"go-goal/internal/models"
)

// CreateGoal is the resolver for the createGoal field.
func (r *mutationResolver) CreateGoal(ctx context.Context, input CreateGoalInput) (*Goal, error) {
	var g models.Goal
	now := time.Now()

	err := r.DB.QueryRow(`
		INSERT INTO goals (title, description, priority, due_date, status, project_id, context_id, created_at, updated_at) 
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) 
		RETURNING id, title, description, priority, due_date, status, project_id, context_id, created_at, updated_at
	`, input.Title, input.Description, input.Priority, input.DueDate, input.Status, input.ProjectID, input.ContextID, now, now).Scan(
		&g.ID, &g.Title, &g.Description, &g.Priority, &g.DueDate, &g.Status, &g.ProjectID, &g.ContextID, &g.CreatedAt, &g.UpdatedAt)

	if err != nil {
		return nil, fmt.Errorf("failed to create goal: %w", err)
	}

	return &Goal{
		ID:          g.ID,
		Title:       g.Title,
		Description: &g.Description,
		Priority:    fmt.Sprintf("%d", g.Priority),
		DueDate:     g.DueDate,
		Status:      g.Status,
		ProjectID:   *g.ProjectID,
		CreatedAt:   g.CreatedAt,
		UpdatedAt:   g.UpdatedAt,
	}, nil
}

// UpdateGoal is the resolver for the updateGoal field.
func (r *mutationResolver) UpdateGoal(ctx context.Context, id string, input UpdateGoalInput) (*Goal, error) {
	goalID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid goal ID: %w", err)
	}

	// Build dynamic update query
	query := "UPDATE goals SET updated_at = $1"
	args := []interface{}{time.Now()}
	argIndex := 2

	if input.Title != nil {
		query += fmt.Sprintf(", title = $%d", argIndex)
		args = append(args, *input.Title)
		argIndex++
	}
	if input.Description != nil {
		query += fmt.Sprintf(", description = $%d", argIndex)
		args = append(args, *input.Description)
		argIndex++
	}
	if input.Priority != nil {
		query += fmt.Sprintf(", priority = $%d", argIndex)
		args = append(args, *input.Priority)
		argIndex++
	}
	if input.Status != nil {
		query += fmt.Sprintf(", status = $%d", argIndex)
		args = append(args, *input.Status)
		argIndex++
	}
	if input.DueDate != nil {
		query += fmt.Sprintf(", due_date = $%d", argIndex)
		args = append(args, *input.DueDate)
		argIndex++
	}
	if input.ProjectID != nil {
		query += fmt.Sprintf(", project_id = $%d", argIndex)
		args = append(args, *input.ProjectID)
		argIndex++
	}

	query += fmt.Sprintf(" WHERE id = $%d RETURNING id, title, description, priority, due_date, status, project_id, context_id, created_at, updated_at", argIndex)
	args = append(args, goalID)

	var g models.Goal
	err = r.DB.QueryRow(query, args...).Scan(
		&g.ID, &g.Title, &g.Description, &g.Priority, &g.DueDate, &g.Status, &g.ProjectID, &g.ContextID, &g.CreatedAt, &g.UpdatedAt)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("goal not found")
	}
	if err != nil {
		return nil, fmt.Errorf("failed to update goal: %w", err)
	}

	return &Goal{
		ID:          g.ID,
		Title:       g.Title,
		Description: &g.Description,
		Priority:    fmt.Sprintf("%d", g.Priority),
		DueDate:     g.DueDate,
		Status:      g.Status,
		ProjectID:   *g.ProjectID,
		CreatedAt:   g.CreatedAt,
		UpdatedAt:   g.UpdatedAt,
	}, nil
}

// DeleteGoal is the resolver for the deleteGoal field.
func (r *mutationResolver) DeleteGoal(ctx context.Context, id string) (bool, error) {
	goalID, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid goal ID: %w", err)
	}

	result, err := r.DB.Exec("DELETE FROM goals WHERE id = $1", goalID)
	if err != nil {
		return false, fmt.Errorf("failed to delete goal: %w", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		return false, fmt.Errorf("goal not found")
	}

	return true, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context, workspaceID *int) (*Dashboard, error) {
	// Get today's tasks
	todayTasks := []*Task{}
	tasksQuery := `SELECT id, title, description, status, priority, due_date, goal_id, project_id, context_id, created_at, updated_at 
				  FROM tasks WHERE DATE(due_date) = CURRENT_DATE OR status = 'in_progress' ORDER BY priority DESC LIMIT 10`
	tasksRows, err := r.DB.Query(tasksQuery)
	if err == nil {
		defer tasksRows.Close()
		for tasksRows.Next() {
			var t models.Task
			tasksRows.Scan(&t.ID, &t.Title, &t.Description, &t.Status, &t.Priority, &t.DueDate, &t.GoalID, &t.ProjectID, &t.ContextID, &t.CreatedAt, &t.UpdatedAt)
			todayTasks = append(todayTasks, &Task{
				ID:          t.ID,
				Title:       t.Title,
				Description: &t.Description,
				Status:      t.Status,
				Priority:    fmt.Sprintf("%d", t.Priority),
				DueDate:     t.DueDate,
				GoalID:      t.GoalID,
				ProjectID:   *t.ProjectID,
				CreatedAt:   t.CreatedAt,
				UpdatedAt:   t.UpdatedAt,
			})
		}
	}

	// Get recent projects
	recentProjects := []*Project{}
	projectsQuery := `SELECT id, title, description, status, workspace_id, created_at, updated_at 
					  FROM projects ORDER BY updated_at DESC LIMIT 5`
	projectsRows, err := r.DB.Query(projectsQuery)
	if err == nil {
		defer projectsRows.Close()
		for projectsRows.Next() {
			var p models.Project
			projectsRows.Scan(&p.ID, &p.Title, &p.Description, &p.Status, &p.WorkspaceID, &p.CreatedAt, &p.UpdatedAt)
			recentProjects = append(recentProjects, &Project{
				ID:          p.ID,
				Title:       p.Title,
				Description: &p.Description,
				Status:      p.Status,
				WorkspaceID: *p.WorkspaceID,
				CreatedAt:   p.CreatedAt,
				UpdatedAt:   p.UpdatedAt,
			})
		}
	}

	// Get upcoming goals
	upcomingGoals := []*Goal{}
	goalsQuery := `SELECT id, title, description, priority, due_date, status, project_id, context_id, created_at, updated_at 
				   FROM goals WHERE due_date > CURRENT_DATE ORDER BY due_date ASC LIMIT 5`
	goalsRows, err := r.DB.Query(goalsQuery)
	if err == nil {
		defer goalsRows.Close()
		for goalsRows.Next() {
			var g models.Goal
			goalsRows.Scan(&g.ID, &g.Title, &g.Description, &g.Priority, &g.DueDate, &g.Status, &g.ProjectID, &g.ContextID, &g.CreatedAt, &g.UpdatedAt)
			upcomingGoals = append(upcomingGoals, &Goal{
				ID:          g.ID,
				Title:       g.Title,
				Description: &g.Description,
				Priority:    fmt.Sprintf("%d", g.Priority),
				DueDate:     g.DueDate,
				Status:      g.Status,
				ProjectID:   *g.ProjectID,
				CreatedAt:   g.CreatedAt,
				UpdatedAt:   g.UpdatedAt,
			})
		}
	}

	// Get workspace stats
	var totalProjects, totalGoals, totalTasks, completedTasks, pendingTasks int
	r.DB.QueryRow("SELECT COUNT(*) FROM projects").Scan(&totalProjects)
	r.DB.QueryRow("SELECT COUNT(*) FROM goals").Scan(&totalGoals)
	r.DB.QueryRow("SELECT COUNT(*) FROM tasks").Scan(&totalTasks)
	r.DB.QueryRow("SELECT COUNT(*) FROM tasks WHERE status = 'completed'").Scan(&completedTasks)
	r.DB.QueryRow("SELECT COUNT(*) FROM tasks WHERE status IN ('pending', 'in_progress')").Scan(&pendingTasks)

	workspaceStats := &WorkspaceStats{
		TotalProjects:  totalProjects,
		TotalGoals:     totalGoals,
		TotalTasks:     totalTasks,
		CompletedTasks: completedTasks,
		PendingTasks:   pendingTasks,
	}

	return &Dashboard{
		TodayTasks:     todayTasks,
		RecentProjects: recentProjects,
		UpcomingGoals:  upcomingGoals,
		WorkspaceStats: workspaceStats,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// Goal returns GoalResolver implementation.
func (r *Resolver) Goal() GoalResolver { return &goalResolver{r} }

// Task returns TaskResolver implementation.
func (r *Resolver) Task() TaskResolver { return &taskResolver{r} }

// Note returns NoteResolver implementation.
func (r *Resolver) Note() NoteResolver { return &noteResolver{r} }

// Tag returns TagResolver implementation.
func (r *Resolver) Tag() TagResolver { return &tagResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type goalResolver struct{ *Resolver }
type taskResolver struct{ *Resolver }
type noteResolver struct{ *Resolver }
type tagResolver struct{ *Resolver }
// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"context"
	"embed"
	"errors"
	"fmt"

	"github.com/99designs/gqlgen/graphql"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type MutationResolver interface {
	CreateFlow(ctx context.Context, input CreateFlowInput) (*Flow, error)
	UpdateFlow(ctx context.Context, id string, input UpdateFlowInput) (*Flow, error)
	DeleteFlow(ctx context.Context, id string) (bool, error)
}

type QueryResolver interface {
	Flows(ctx context.Context, workspaceID *int) ([]*Flow, error)
	Flow(ctx context.Context, id string) (*Flow, error)
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return nil
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, make(chan graphql.DeferredResult), 0, make(chan graphql.DeferredResult)}
	_ = ec
	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			return nil
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			return nil
		}
	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        chan graphql.DeferredResult
	pendingDeferred int
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) introspectSchema() (interface{}, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return nil, nil
}

func (ec *executionContext) introspectType(name string) (interface{}, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return nil, nil
}

//go:embed "schema.graphqls"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema.graphqls", Input: sourceData("schema.graphqls"), BuiltIn: false},
}

// endregion ************************** generated!.gotpl **************************